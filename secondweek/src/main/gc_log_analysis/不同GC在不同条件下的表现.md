# 不同GC在不同条件下的表现

统计的数据在当前文件夹下. 文件名使用下划线分开, 第一部分表示使用的拉力机收集器, 第二部分表示使用的堆内存大小, 第三部分multi表示使用多线程, 第三部分的serial表示使用了`-XX:ParalelGCThreads=1`选项. 第四部分表示分析的应用生成的对象个数. 

测试的应用是GClogAnalysis.java

## Serial GC

- `-XX:UseSerialGC` 使用串行GC回收年轻代, JVM会自动设定Serial Old GC作为老年代的垃圾回收器. 他们在运行时不仅自己是单线程, 而且需要STW, 要暂停所有应用线程. 
- 适合在单核低内存下使用. 在内存比较小的请款情况下堆内存改变比较敏感. 例如在256m堆内存时执行了38次GC, 生成了4321个对象. 在1g堆内存时执行了7次GC, 生成了7198个对象.

## Parallel GC

- `-XX:UseParallelGC`使用Parallel Scavenge GC回收年轻代, JVM自动设定Parallel Old GC回收老年代. 它们在运行时也需要进行STW. 不过可以多线程执行.
- 它们在多核机器中以多线程以及1-4G堆内存表现最好. 例如统计数据中在多核1G堆内存的情况下生成11198个对象.更高的内存可以减少垃圾回收次数. 统计数据中1G堆内存垃圾收集了18次, 4G时垃圾收集 1次, 8G内存时就没有收集. 8G时的响应应该是延迟最小的吧.

## CMS GC

- `-XX:+UseConcMarkSweepGC` 使用CMS 回收老年代, JVM默认设定ParNew 进行年轻代垃圾回收. 它以响应速度优先. 在垃圾收集时分多个步骤进行, 只有初始标记和最终标记需要进行STW. 其他时候可以和应用线程并发处理. 所以响应速度高.
- 它比较适合多核的BS系统, 因为其特性可以满足使用者低延迟的要求. 总体吞吐量并不比Parallel GC好

## G1 GC

- `-XX:+UseG1GC` 使用G1回收年轻代和老年代. 它的内部将堆内存分为多个Region. 每个Region根据需要时可以转换身份作为年轻代, 老年代等. 
- 他比较适合多核大内存的系统. 很能发挥大内存的优势. 在统计中8g堆内存1278个对象.而且只进行了9次垃圾回收.
- 它的性能非常好, 在只用1g单线程时, 进行了20次垃圾回收, 却产生了7199个对象.
- 内存过小时则无法运行. 统计中256m堆内存时, 无论单线程还是多线程都会抛出OutOfMemoryError.